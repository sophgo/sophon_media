# This file was automatically generated by SWIG (http://www.swig.org).
# Version 3.0.10
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.




"""Python interface to libmraa"""


from sys import version_info as _swig_python_version_info
if _swig_python_version_info >= (2, 7, 0):
    def swig_import_helper():
        import importlib
        pkg = __name__.rpartition('.')[0]
        mname = '.'.join((pkg, '_mraa')).lstrip('.')
        try:
            return importlib.import_module(mname)
        except ImportError:
            return importlib.import_module('_mraa')
    _mraa = swig_import_helper()
    del swig_import_helper
elif _swig_python_version_info >= (2, 6, 0):
    def swig_import_helper():
        from os.path import dirname
        import imp
        fp = None
        try:
            fp, pathname, description = imp.find_module('_mraa', [dirname(__file__)])
        except ImportError:
            import _mraa
            return _mraa
        if fp is not None:
            try:
                _mod = imp.load_module('_mraa', fp, pathname, description)
            finally:
                fp.close()
            return _mod
    _mraa = swig_import_helper()
    del swig_import_helper
else:
    import _mraa
del _swig_python_version_info
try:
    _swig_property = property
except NameError:
    pass  # Python < 2.2 doesn't have 'property'.

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_setattr_nondynamic(self, class_type, name, value, static=1):
    if (name == "thisown"):
        return self.this.own(value)
    if (name == "this"):
        if type(value).__name__ == 'SwigPyObject':
            self.__dict__[name] = value
            return
    method = class_type.__swig_setmethods__.get(name, None)
    if method:
        return method(self, value)
    if (not static):
        if _newclass:
            object.__setattr__(self, name, value)
        else:
            self.__dict__[name] = value
    else:
        raise AttributeError("You cannot add attributes to %s" % self)


def _swig_setattr(self, class_type, name, value):
    return _swig_setattr_nondynamic(self, class_type, name, value, 0)


def _swig_getattr(self, class_type, name):
    if (name == "thisown"):
        return self.this.own()
    method = class_type.__swig_getmethods__.get(name, None)
    if method:
        return method(self)
    raise AttributeError("'%s' object has no attribute '%s'" % (class_type.__name__, name))


def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)

try:
    _object = object
    _newclass = 1
except __builtin__.Exception:
    class _object:
        pass
    _newclass = 0

class uint8Array(_object):
    """Proxy of C++ uint8Array class."""

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, uint8Array, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, uint8Array, name)
    __repr__ = _swig_repr

    def __init__(self, nelements):
        """
        __init__(uint8Array self, size_t nelements) -> uint8Array

        Parameters
        ----------
        nelements: size_t

        """
        this = _mraa.new_uint8Array(nelements)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mraa.delete_uint8Array
    __del__ = lambda self: None

    def __getitem__(self, index):
        """
        __getitem__(uint8Array self, size_t index) -> uint8_t

        Parameters
        ----------
        index: size_t

        """
        return _mraa.uint8Array___getitem__(self, index)


    def __setitem__(self, index, value):
        """
        __setitem__(uint8Array self, size_t index, uint8_t value)

        Parameters
        ----------
        index: size_t
        value: uint8_t

        """
        return _mraa.uint8Array___setitem__(self, index, value)


    def cast(self):
        """
        cast(uint8Array self) -> uint8_t *

        Parameters
        ----------
        self: uint8Array *

        """
        return _mraa.uint8Array_cast(self)


    def frompointer(t):
        """
        frompointer(uint8_t * t) -> uint8Array

        Parameters
        ----------
        t: uint8_t *

        """
        return _mraa.uint8Array_frompointer(t)

    frompointer = staticmethod(frompointer)
uint8Array_swigregister = _mraa.uint8Array_swigregister
uint8Array_swigregister(uint8Array)

def uint8Array_frompointer(t):
    """
    uint8Array_frompointer(uint8_t * t) -> uint8Array

    Parameters
    ----------
    t: uint8_t *

    """
    return _mraa.uint8Array_frompointer(t)

INTEL_GALILEO_GEN1 = _mraa.INTEL_GALILEO_GEN1
INTEL_GALILEO_GEN2 = _mraa.INTEL_GALILEO_GEN2
INTEL_EDISON_FAB_C = _mraa.INTEL_EDISON_FAB_C
INTEL_DE3815 = _mraa.INTEL_DE3815
INTEL_MINNOWBOARD_MAX = _mraa.INTEL_MINNOWBOARD_MAX
RASPBERRY_PI = _mraa.RASPBERRY_PI
BEAGLEBONE = _mraa.BEAGLEBONE
BANANA = _mraa.BANANA
INTEL_NUC5 = _mraa.INTEL_NUC5
A96BOARDS = _mraa.A96BOARDS
INTEL_SOFIA_3GR = _mraa.INTEL_SOFIA_3GR
INTEL_CHERRYHILLS = _mraa.INTEL_CHERRYHILLS
INTEL_UP = _mraa.INTEL_UP
INTEL_GT_TUCHUCK = _mraa.INTEL_GT_TUCHUCK
FTDI_FT4222 = _mraa.FTDI_FT4222
GENERIC_FIRMATA = _mraa.GENERIC_FIRMATA
NULL_PLATFORM = _mraa.NULL_PLATFORM
UNKNOWN_PLATFORM = _mraa.UNKNOWN_PLATFORM
INTEL_EDISON_MINIBOARD_J17_1 = _mraa.INTEL_EDISON_MINIBOARD_J17_1
INTEL_EDISON_MINIBOARD_J17_5 = _mraa.INTEL_EDISON_MINIBOARD_J17_5
INTEL_EDISON_MINIBOARD_J17_7 = _mraa.INTEL_EDISON_MINIBOARD_J17_7
INTEL_EDISON_MINIBOARD_J17_8 = _mraa.INTEL_EDISON_MINIBOARD_J17_8
INTEL_EDISON_MINIBOARD_J17_9 = _mraa.INTEL_EDISON_MINIBOARD_J17_9
INTEL_EDISON_MINIBOARD_J17_10 = _mraa.INTEL_EDISON_MINIBOARD_J17_10
INTEL_EDISON_MINIBOARD_J17_11 = _mraa.INTEL_EDISON_MINIBOARD_J17_11
INTEL_EDISON_MINIBOARD_J17_12 = _mraa.INTEL_EDISON_MINIBOARD_J17_12
INTEL_EDISON_MINIBOARD_J17_14 = _mraa.INTEL_EDISON_MINIBOARD_J17_14
INTEL_EDISON_MINIBOARD_J18_1 = _mraa.INTEL_EDISON_MINIBOARD_J18_1
INTEL_EDISON_MINIBOARD_J18_2 = _mraa.INTEL_EDISON_MINIBOARD_J18_2
INTEL_EDISON_MINIBOARD_J18_6 = _mraa.INTEL_EDISON_MINIBOARD_J18_6
INTEL_EDISON_MINIBOARD_J18_7 = _mraa.INTEL_EDISON_MINIBOARD_J18_7
INTEL_EDISON_MINIBOARD_J18_8 = _mraa.INTEL_EDISON_MINIBOARD_J18_8
INTEL_EDISON_MINIBOARD_J18_10 = _mraa.INTEL_EDISON_MINIBOARD_J18_10
INTEL_EDISON_MINIBOARD_J18_11 = _mraa.INTEL_EDISON_MINIBOARD_J18_11
INTEL_EDISON_MINIBOARD_J18_12 = _mraa.INTEL_EDISON_MINIBOARD_J18_12
INTEL_EDISON_MINIBOARD_J18_13 = _mraa.INTEL_EDISON_MINIBOARD_J18_13
INTEL_EDISON_MINIBOARD_J19_4 = _mraa.INTEL_EDISON_MINIBOARD_J19_4
INTEL_EDISON_MINIBOARD_J19_5 = _mraa.INTEL_EDISON_MINIBOARD_J19_5
INTEL_EDISON_MINIBOARD_J19_6 = _mraa.INTEL_EDISON_MINIBOARD_J19_6
INTEL_EDISON_MINIBOARD_J19_8 = _mraa.INTEL_EDISON_MINIBOARD_J19_8
INTEL_EDISON_MINIBOARD_J19_9 = _mraa.INTEL_EDISON_MINIBOARD_J19_9
INTEL_EDISON_MINIBOARD_J19_10 = _mraa.INTEL_EDISON_MINIBOARD_J19_10
INTEL_EDISON_MINIBOARD_J19_11 = _mraa.INTEL_EDISON_MINIBOARD_J19_11
INTEL_EDISON_MINIBOARD_J19_12 = _mraa.INTEL_EDISON_MINIBOARD_J19_12
INTEL_EDISON_MINIBOARD_J19_13 = _mraa.INTEL_EDISON_MINIBOARD_J19_13
INTEL_EDISON_MINIBOARD_J19_14 = _mraa.INTEL_EDISON_MINIBOARD_J19_14
INTEL_EDISON_MINIBOARD_J20_3 = _mraa.INTEL_EDISON_MINIBOARD_J20_3
INTEL_EDISON_MINIBOARD_J20_4 = _mraa.INTEL_EDISON_MINIBOARD_J20_4
INTEL_EDISON_MINIBOARD_J20_5 = _mraa.INTEL_EDISON_MINIBOARD_J20_5
INTEL_EDISON_MINIBOARD_J20_6 = _mraa.INTEL_EDISON_MINIBOARD_J20_6
INTEL_EDISON_MINIBOARD_J20_7 = _mraa.INTEL_EDISON_MINIBOARD_J20_7
INTEL_EDISON_MINIBOARD_J20_8 = _mraa.INTEL_EDISON_MINIBOARD_J20_8
INTEL_EDISON_MINIBOARD_J20_9 = _mraa.INTEL_EDISON_MINIBOARD_J20_9
INTEL_EDISON_MINIBOARD_J20_10 = _mraa.INTEL_EDISON_MINIBOARD_J20_10
INTEL_EDISON_MINIBOARD_J20_11 = _mraa.INTEL_EDISON_MINIBOARD_J20_11
INTEL_EDISON_MINIBOARD_J20_12 = _mraa.INTEL_EDISON_MINIBOARD_J20_12
INTEL_EDISON_MINIBOARD_J20_13 = _mraa.INTEL_EDISON_MINIBOARD_J20_13
INTEL_EDISON_MINIBOARD_J20_14 = _mraa.INTEL_EDISON_MINIBOARD_J20_14
INTEL_EDISON_GP182 = _mraa.INTEL_EDISON_GP182
INTEL_EDISON_GP135 = _mraa.INTEL_EDISON_GP135
INTEL_EDISON_GP27 = _mraa.INTEL_EDISON_GP27
INTEL_EDISON_GP20 = _mraa.INTEL_EDISON_GP20
INTEL_EDISON_GP28 = _mraa.INTEL_EDISON_GP28
INTEL_EDISON_GP111 = _mraa.INTEL_EDISON_GP111
INTEL_EDISON_GP109 = _mraa.INTEL_EDISON_GP109
INTEL_EDISON_GP115 = _mraa.INTEL_EDISON_GP115
INTEL_EDISON_GP128 = _mraa.INTEL_EDISON_GP128
INTEL_EDISON_GP13 = _mraa.INTEL_EDISON_GP13
INTEL_EDISON_GP165 = _mraa.INTEL_EDISON_GP165
INTEL_EDISON_GP19 = _mraa.INTEL_EDISON_GP19
INTEL_EDISON_GP12 = _mraa.INTEL_EDISON_GP12
INTEL_EDISON_GP183 = _mraa.INTEL_EDISON_GP183
INTEL_EDISON_GP110 = _mraa.INTEL_EDISON_GP110
INTEL_EDISON_GP114 = _mraa.INTEL_EDISON_GP114
INTEL_EDISON_GP129 = _mraa.INTEL_EDISON_GP129
INTEL_EDISON_GP130 = _mraa.INTEL_EDISON_GP130
INTEL_EDISON_GP44 = _mraa.INTEL_EDISON_GP44
INTEL_EDISON_GP46 = _mraa.INTEL_EDISON_GP46
INTEL_EDISON_GP48 = _mraa.INTEL_EDISON_GP48
INTEL_EDISON_GP131 = _mraa.INTEL_EDISON_GP131
INTEL_EDISON_GP14 = _mraa.INTEL_EDISON_GP14
INTEL_EDISON_GP40 = _mraa.INTEL_EDISON_GP40
INTEL_EDISON_GP43 = _mraa.INTEL_EDISON_GP43
INTEL_EDISON_GP77 = _mraa.INTEL_EDISON_GP77
INTEL_EDISON_GP82 = _mraa.INTEL_EDISON_GP82
INTEL_EDISON_GP83 = _mraa.INTEL_EDISON_GP83
INTEL_EDISON_GP134 = _mraa.INTEL_EDISON_GP134
INTEL_EDISON_GP45 = _mraa.INTEL_EDISON_GP45
INTEL_EDISON_GP47 = _mraa.INTEL_EDISON_GP47
INTEL_EDISON_GP49 = _mraa.INTEL_EDISON_GP49
INTEL_EDISON_GP15 = _mraa.INTEL_EDISON_GP15
INTEL_EDISON_GP84 = _mraa.INTEL_EDISON_GP84
INTEL_EDISON_GP42 = _mraa.INTEL_EDISON_GP42
INTEL_EDISON_GP41 = _mraa.INTEL_EDISON_GP41
INTEL_EDISON_GP78 = _mraa.INTEL_EDISON_GP78
INTEL_EDISON_GP79 = _mraa.INTEL_EDISON_GP79
INTEL_EDISON_GP80 = _mraa.INTEL_EDISON_GP80
INTEL_EDISON_GP81 = _mraa.INTEL_EDISON_GP81
RASPBERRY_WIRING_PIN8 = _mraa.RASPBERRY_WIRING_PIN8
RASPBERRY_WIRING_PIN9 = _mraa.RASPBERRY_WIRING_PIN9
RASPBERRY_WIRING_PIN7 = _mraa.RASPBERRY_WIRING_PIN7
RASPBERRY_WIRING_PIN15 = _mraa.RASPBERRY_WIRING_PIN15
RASPBERRY_WIRING_PIN16 = _mraa.RASPBERRY_WIRING_PIN16
RASPBERRY_WIRING_PIN0 = _mraa.RASPBERRY_WIRING_PIN0
RASPBERRY_WIRING_PIN1 = _mraa.RASPBERRY_WIRING_PIN1
RASPBERRY_WIRING_PIN2 = _mraa.RASPBERRY_WIRING_PIN2
RASPBERRY_WIRING_PIN3 = _mraa.RASPBERRY_WIRING_PIN3
RASPBERRY_WIRING_PIN4 = _mraa.RASPBERRY_WIRING_PIN4
RASPBERRY_WIRING_PIN5 = _mraa.RASPBERRY_WIRING_PIN5
RASPBERRY_WIRING_PIN12 = _mraa.RASPBERRY_WIRING_PIN12
RASPBERRY_WIRING_PIN13 = _mraa.RASPBERRY_WIRING_PIN13
RASPBERRY_WIRING_PIN6 = _mraa.RASPBERRY_WIRING_PIN6
RASPBERRY_WIRING_PIN14 = _mraa.RASPBERRY_WIRING_PIN14
RASPBERRY_WIRING_PIN10 = _mraa.RASPBERRY_WIRING_PIN10
RASPBERRY_WIRING_PIN11 = _mraa.RASPBERRY_WIRING_PIN11
RASPBERRY_WIRING_PIN17 = _mraa.RASPBERRY_WIRING_PIN17
RASPBERRY_WIRING_PIN21 = _mraa.RASPBERRY_WIRING_PIN21
RASPBERRY_WIRING_PIN18 = _mraa.RASPBERRY_WIRING_PIN18
RASPBERRY_WIRING_PIN19 = _mraa.RASPBERRY_WIRING_PIN19
RASPBERRY_WIRING_PIN22 = _mraa.RASPBERRY_WIRING_PIN22
RASPBERRY_WIRING_PIN20 = _mraa.RASPBERRY_WIRING_PIN20
RASPBERRY_WIRING_PIN26 = _mraa.RASPBERRY_WIRING_PIN26
RASPBERRY_WIRING_PIN23 = _mraa.RASPBERRY_WIRING_PIN23
RASPBERRY_WIRING_PIN24 = _mraa.RASPBERRY_WIRING_PIN24
RASPBERRY_WIRING_PIN27 = _mraa.RASPBERRY_WIRING_PIN27
RASPBERRY_WIRING_PIN25 = _mraa.RASPBERRY_WIRING_PIN25
RASPBERRY_WIRING_PIN28 = _mraa.RASPBERRY_WIRING_PIN28
RASPBERRY_WIRING_PIN29 = _mraa.RASPBERRY_WIRING_PIN29
SUCCESS = _mraa.SUCCESS
ERROR_FEATURE_NOT_IMPLEMENTED = _mraa.ERROR_FEATURE_NOT_IMPLEMENTED
ERROR_FEATURE_NOT_SUPPORTED = _mraa.ERROR_FEATURE_NOT_SUPPORTED
ERROR_INVALID_VERBOSITY_LEVEL = _mraa.ERROR_INVALID_VERBOSITY_LEVEL
ERROR_INVALID_PARAMETER = _mraa.ERROR_INVALID_PARAMETER
ERROR_INVALID_HANDLE = _mraa.ERROR_INVALID_HANDLE
ERROR_NO_RESOURCES = _mraa.ERROR_NO_RESOURCES
ERROR_INVALID_RESOURCE = _mraa.ERROR_INVALID_RESOURCE
ERROR_INVALID_QUEUE_TYPE = _mraa.ERROR_INVALID_QUEUE_TYPE
ERROR_NO_DATA_AVAILABLE = _mraa.ERROR_NO_DATA_AVAILABLE
ERROR_INVALID_PLATFORM = _mraa.ERROR_INVALID_PLATFORM
ERROR_PLATFORM_NOT_INITIALISED = _mraa.ERROR_PLATFORM_NOT_INITIALISED
ERROR_UART_OW_SHORTED = _mraa.ERROR_UART_OW_SHORTED
ERROR_UART_OW_NO_DEVICES = _mraa.ERROR_UART_OW_NO_DEVICES
ERROR_UART_OW_DATA_ERROR = _mraa.ERROR_UART_OW_DATA_ERROR
ERROR_UNSPECIFIED = _mraa.ERROR_UNSPECIFIED
PIN_VALID = _mraa.PIN_VALID
PIN_GPIO = _mraa.PIN_GPIO
PIN_PWM = _mraa.PIN_PWM
PIN_FAST_GPIO = _mraa.PIN_FAST_GPIO
PIN_SPI = _mraa.PIN_SPI
PIN_I2C = _mraa.PIN_I2C
PIN_AIO = _mraa.PIN_AIO
PIN_UART = _mraa.PIN_UART
I2C_STD = _mraa.I2C_STD
I2C_FAST = _mraa.I2C_FAST
I2C_HIGH = _mraa.I2C_HIGH
UART_PARITY_NONE = _mraa.UART_PARITY_NONE
UART_PARITY_EVEN = _mraa.UART_PARITY_EVEN
UART_PARITY_ODD = _mraa.UART_PARITY_ODD
UART_PARITY_MARK = _mraa.UART_PARITY_MARK
UART_PARITY_SPACE = _mraa.UART_PARITY_SPACE

def init():
    """init() -> mraa::Result"""
    return _mraa.init()

def getVersion():
    """getVersion() -> std::string"""
    return _mraa.getVersion()

def setPriority(priority):
    """
    setPriority(int const priority) -> int

    Parameters
    ----------
    priority: int const

    """
    return _mraa.setPriority(priority)

def getPlatformType():
    """getPlatformType() -> mraa::Platform"""
    return _mraa.getPlatformType()

def printError(result):
    """
    printError(mraa::Result result)

    Parameters
    ----------
    result: enum mraa::Result

    """
    return _mraa.printError(result)

def pinModeTest(pin, mode):
    """
    pinModeTest(int pin, mraa::Pinmodes mode) -> bool

    Parameters
    ----------
    pin: int
    mode: enum mraa::Pinmodes

    """
    return _mraa.pinModeTest(pin, mode)

def adcRawBits():
    """adcRawBits() -> unsigned int"""
    return _mraa.adcRawBits()

def adcSupportedBits():
    """adcSupportedBits() -> unsigned int"""
    return _mraa.adcSupportedBits()

def getPlatformName():
    """getPlatformName() -> std::string"""
    return _mraa.getPlatformName()

def getPlatformVersion(*args):
    """
    getPlatformVersion(int platform_offset) -> std::string

    Parameters
    ----------
    platform_offset: int

    getPlatformVersion() -> std::string
    """
    return _mraa.getPlatformVersion(*args)

def getPinCount():
    """getPinCount() -> unsigned int"""
    return _mraa.getPinCount()

def getI2cBusCount():
    """getI2cBusCount() -> int"""
    return _mraa.getI2cBusCount()

def getI2cBusId(i2c_bus):
    """
    getI2cBusId(int i2c_bus) -> int

    Parameters
    ----------
    i2c_bus: int

    """
    return _mraa.getI2cBusId(i2c_bus)

def getPinName(pin):
    """
    getPinName(int pin) -> std::string

    Parameters
    ----------
    pin: int

    """
    return _mraa.getPinName(pin)

def setLogLevel(level):
    """
    setLogLevel(int level) -> mraa::Result

    Parameters
    ----------
    level: int

    """
    return _mraa.setLogLevel(level)

def hasSubPlatform():
    """hasSubPlatform() -> bool"""
    return _mraa.hasSubPlatform()

def isSubPlatformId(pin_or_bus_id):
    """
    isSubPlatformId(int pin_or_bus_id) -> bool

    Parameters
    ----------
    pin_or_bus_id: int

    """
    return _mraa.isSubPlatformId(pin_or_bus_id)

def getSubPlatformId(pin_or_bus_index):
    """
    getSubPlatformId(int pin_or_bus_index) -> int

    Parameters
    ----------
    pin_or_bus_index: int

    """
    return _mraa.getSubPlatformId(pin_or_bus_index)

def getSubPlatformIndex(pin_or_bus_id):
    """
    getSubPlatformIndex(int pin_or_bus_id) -> int

    Parameters
    ----------
    pin_or_bus_id: int

    """
    return _mraa.getSubPlatformIndex(pin_or_bus_id)

def getDefaultI2cBus(*args):
    """
    getDefaultI2cBus(int platform_offset) -> int

    Parameters
    ----------
    platform_offset: int

    getDefaultI2cBus() -> int
    """
    return _mraa.getDefaultI2cBus(*args)

def addSubplatform(subplatformtype, uart_dev):
    """
    addSubplatform(mraa::Platform subplatformtype, std::string uart_dev) -> mraa::Result

    Parameters
    ----------
    subplatformtype: enum mraa::Platform
    uart_dev: std::string

    """
    return _mraa.addSubplatform(subplatformtype, uart_dev)

def removeSubplatform(subplatformtype):
    """
    removeSubplatform(mraa::Platform subplatformtype) -> mraa::Result

    Parameters
    ----------
    subplatformtype: enum mraa::Platform

    """
    return _mraa.removeSubplatform(subplatformtype)

def initJsonPlatform(path):
    """
    initJsonPlatform(std::string path) -> mraa::Result

    Parameters
    ----------
    path: std::string

    """
    return _mraa.initJsonPlatform(path)

def gpioFromDesc(desc):
    """
    gpioFromDesc(std::string desc) -> Gpio

    Parameters
    ----------
    desc: std::string

    """
    return _mraa.gpioFromDesc(desc)

def aioFromDesc(desc):
    """
    aioFromDesc(std::string desc) -> Aio

    Parameters
    ----------
    desc: std::string

    """
    return _mraa.aioFromDesc(desc)

def uartFromDesc(desc):
    """
    uartFromDesc(std::string desc) -> Uart

    Parameters
    ----------
    desc: std::string

    """
    return _mraa.uartFromDesc(desc)

def spiFromDesc(desc):
    """
    spiFromDesc(std::string desc) -> Spi

    Parameters
    ----------
    desc: std::string

    """
    return _mraa.spiFromDesc(desc)

def i2cFromDesc(desc):
    """
    i2cFromDesc(std::string desc) -> I2c

    Parameters
    ----------
    desc: std::string

    """
    return _mraa.i2cFromDesc(desc)

def pwmFromDesc(desc):
    """
    pwmFromDesc(std::string desc) -> Pwm

    Parameters
    ----------
    desc: std::string

    """
    return _mraa.pwmFromDesc(desc)
MODE_STRONG = _mraa.MODE_STRONG
MODE_PULLUP = _mraa.MODE_PULLUP
MODE_PULLDOWN = _mraa.MODE_PULLDOWN
MODE_HIZ = _mraa.MODE_HIZ
DIR_OUT = _mraa.DIR_OUT
DIR_IN = _mraa.DIR_IN
DIR_OUT_HIGH = _mraa.DIR_OUT_HIGH
DIR_OUT_LOW = _mraa.DIR_OUT_LOW
EDGE_NONE = _mraa.EDGE_NONE
EDGE_BOTH = _mraa.EDGE_BOTH
EDGE_RISING = _mraa.EDGE_RISING
EDGE_FALLING = _mraa.EDGE_FALLING
class Gpio(_object):
    """


    API to General Purpose IO.

    This file defines the gpio interface for libmraa

    C++ includes: gpio.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Gpio, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Gpio, name)
    __repr__ = _swig_repr

    def __init__(self, pin, owner=True, raw=False):
        """
        __init__(mraa::Gpio self, int pin, bool owner=True, bool raw=False) -> Gpio

        Parameters
        ----------
        pin: int
        owner: bool
        raw: bool

        __init__(mraa::Gpio self, int pin, bool owner=True) -> Gpio

        Parameters
        ----------
        pin: int
        owner: bool

        __init__(mraa::Gpio self, int pin) -> Gpio

        Parameters
        ----------
        pin: int




        Gpio Constructor, takes a pointer to the GPIO context and initialises
        the GPIO class

        Parameters:
        -----------

        void:  * to GPIO context 
        """
        this = _mraa.new_Gpio(pin, owner, raw)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mraa.delete_Gpio
    __del__ = lambda self: None

    def edge(self, mode):
        """
        edge(Gpio self, mraa::Edge mode) -> mraa::Result

        Parameters
        ----------
        mode: enum mraa::Edge




        Set the edge mode for ISR

        Parameters:
        -----------

        mode:  The edge mode to set

        Result of operation 
        """
        return _mraa.Gpio_edge(self, mode)


    def isr(self, mode, pyfunc, args):
        """
        isr(Gpio self, mraa::Edge mode, PyObject * pyfunc, PyObject * args) -> mraa::Result

        Parameters
        ----------
        mode: enum mraa::Edge
        pyfunc: PyObject *
        args: PyObject *




        Sets a callback to be called when pin value changes

        Parameters:
        -----------

        mode:  The edge mode to set

        fptr:  Function pointer to function to be called when interrupt is
        triggered

        args:  Arguments passed to the interrupt handler (fptr)

        Result of operation 
        """
        return _mraa.Gpio_isr(self, mode, pyfunc, args)


    def isrExit(self):
        """
        isrExit(Gpio self) -> mraa::Result

        Parameters
        ----------
        self: mraa::Gpio *




        Exits callback - this call will not kill the isr thread immediately
        but only when it is out of it's critical section

        Result of operation 
        """
        return _mraa.Gpio_isrExit(self)


    def mode(self, mode):
        """
        mode(Gpio self, mraa::Mode mode) -> mraa::Result

        Parameters
        ----------
        mode: enum mraa::Mode




        Change Gpio mode

        Parameters:
        -----------

        mode:  The mode to change the gpio into

        Result of operation 
        """
        return _mraa.Gpio_mode(self, mode)


    def dir(self, dir):
        """
        dir(Gpio self, mraa::Dir dir) -> mraa::Result

        Parameters
        ----------
        dir: enum mraa::Dir




        Change Gpio direction

        Parameters:
        -----------

        dir:  The direction to change the gpio into

        Result of operation 
        """
        return _mraa.Gpio_dir(self, dir)


    def readDir(self):
        """
        readDir(Gpio self) -> mraa::Dir

        Parameters
        ----------
        self: mraa::Gpio *




        Read Gpio direction

        Exceptions:
        -----------

        std::runtime_error:  in case of failure

        Result of operation 
        """
        return _mraa.Gpio_readDir(self)


    def read(self):
        """
        read(Gpio self) -> int

        Parameters
        ----------
        self: mraa::Gpio *




        Read value from Gpio

        Gpio value 
        """
        return _mraa.Gpio_read(self)


    def write(self, value):
        """
        write(Gpio self, int value) -> mraa::Result

        Parameters
        ----------
        value: int




        Write value to Gpio

        Parameters:
        -----------

        value:  Value to write to Gpio

        Result of operation 
        """
        return _mraa.Gpio_write(self, value)


    def useMmap(self, enable):
        """
        useMmap(Gpio self, bool enable) -> mraa::Result

        Parameters
        ----------
        enable: bool




        Enable use of mmap i/o if available.

        Parameters:
        -----------

        enable:  true to use mmap

        Result of operation 
        """
        return _mraa.Gpio_useMmap(self, enable)


    def getPin(self, raw=False):
        """
        getPin(Gpio self, bool raw=False) -> int

        Parameters
        ----------
        raw: bool

        getPin(Gpio self) -> int

        Parameters
        ----------
        self: mraa::Gpio *




        Get pin number of Gpio. If raw param is True will return the number as
        used within sysfs. Invalid will return -1.

        Parameters:
        -----------

        raw:  (optional) get the raw gpio number.

        Pin number 
        """
        return _mraa.Gpio_getPin(self, raw)

Gpio_swigregister = _mraa.Gpio_swigregister
Gpio_swigregister(Gpio)

class I2c(_object):
    """


    API to Inter-Integrated Circuit.

    An I2c object represents an i2c master and can talk multiple i2c
    slaves by selecting the correct addressIt is considered best practice
    to make sure the address is correct before doing any calls on i2c, in
    case another application or even thread changed the addres on that
    bus. Multiple instances of the same bus can exist.

    C++ includes: i2c.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, I2c, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, I2c, name)
    __repr__ = _swig_repr

    def __init__(self, bus, raw=False):
        """
        __init__(mraa::I2c self, int bus, bool raw=False) -> I2c

        Parameters
        ----------
        bus: int
        raw: bool

        __init__(mraa::I2c self, int bus) -> I2c

        Parameters
        ----------
        bus: int




        I2C constructor, takes a pointer to a I2C context and initialises the
        I2C class

        Parameters:
        -----------

        void:  * to an I2C context 
        """
        this = _mraa.new_I2c(bus, raw)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mraa.delete_I2c
    __del__ = lambda self: None

    def frequency(self, mode):
        """
        frequency(I2c self, mraa::I2cMode mode) -> mraa::Result

        Parameters
        ----------
        mode: enum mraa::I2cMode




        Sets the i2c Frequency for communication. Your board may not support
        the set frequency. Anyone can change this at any time and this will
        affect every slave on the bus

        Parameters:
        -----------

        mode:  Frequency to set the bus to

        Result of operation 
        """
        return _mraa.I2c_frequency(self, mode)


    def address(self, address):
        """
        address(I2c self, uint8_t address) -> mraa::Result

        Parameters
        ----------
        address: uint8_t




        Set the slave to talk to, typically called before every read/write
        operation

        Parameters:
        -----------

        address:  Communicate to the i2c slave on this address

        Result of operation 
        """
        return _mraa.I2c_address(self, address)


    def readByte(self):
        """
        readByte(I2c self) -> uint8_t

        Parameters
        ----------
        self: mraa::I2c *




        Read exactly one byte from the bus

        Exceptions:
        -----------

        std::invalid_argument:  in case of error

        char read from the bus 
        """
        return _mraa.I2c_readByte(self)


    def read(self, data):
        """
        read(I2c self, uint8_t * data) -> int

        Parameters
        ----------
        data: uint8_t *




        Read length bytes from the bus into *data pointer

        Parameters:
        -----------

        data:  Data to read into

        length:  Size of read in bytes to make

        length of read, should match length 
        """
        return _mraa.I2c_read(self, data)


    def readReg(self, reg):
        """
        readReg(I2c self, uint8_t reg) -> uint8_t

        Parameters
        ----------
        reg: uint8_t




        Read byte from an i2c register

        Parameters:
        -----------

        reg:  Register to read from

        Exceptions:
        -----------

        std::invalid_argument:  in case of error

        char read from register 
        """
        return _mraa.I2c_readReg(self, reg)


    def readWordReg(self, reg):
        """
        readWordReg(I2c self, uint8_t reg) -> uint16_t

        Parameters
        ----------
        reg: uint8_t




        Read word from an i2c register

        Parameters:
        -----------

        reg:  Register to read from

        Exceptions:
        -----------

        std::invalid_argument:  in case of error

        char read from register 
        """
        return _mraa.I2c_readWordReg(self, reg)


    def readBytesReg(self, reg, data):
        """
        readBytesReg(I2c self, uint8_t reg, uint8_t * data) -> int

        Parameters
        ----------
        reg: uint8_t
        data: uint8_t *




        Read length bytes from the bus into *data pointer starting from an i2c
        register

        Parameters:
        -----------

        reg:  Register to read from

        data:  pointer to the byte array to read data in to

        length:  max number of bytes to read

        length passed to the function or -1 
        """
        return _mraa.I2c_readBytesReg(self, reg, data)


    def writeByte(self, data):
        """
        writeByte(I2c self, uint8_t data) -> mraa::Result

        Parameters
        ----------
        data: uint8_t




        Write a byte on the bus

        Parameters:
        -----------

        data:  The byte to send on the bus

        Result of operation 
        """
        return _mraa.I2c_writeByte(self, data)


    def write(self, data):
        """
        write(I2c self, uint8_t const * data) -> mraa::Result

        Parameters
        ----------
        data: uint8_t const *




        Write length bytes to the bus, the first byte in the array is the
        command/register to write

        Parameters:
        -----------

        data:  Buffer to send on the bus, first byte is i2c command

        length:  Size of buffer to send

        Result of operation 
        """
        return _mraa.I2c_write(self, data)


    def writeReg(self, reg, data):
        """
        writeReg(I2c self, uint8_t reg, uint8_t data) -> mraa::Result

        Parameters
        ----------
        reg: uint8_t
        data: uint8_t




        Write a byte to an i2c register

        Parameters:
        -----------

        reg:  Register to write to

        data:  Value to write to register

        Result of operation 
        """
        return _mraa.I2c_writeReg(self, reg, data)


    def writeWordReg(self, reg, data):
        """
        writeWordReg(I2c self, uint8_t reg, uint16_t data) -> mraa::Result

        Parameters
        ----------
        reg: uint8_t
        data: uint16_t




        Write a word to an i2c register

        Parameters:
        -----------

        reg:  Register to write to

        data:  Value to write to register

        Result of operation 
        """
        return _mraa.I2c_writeWordReg(self, reg, data)

I2c_swigregister = _mraa.I2c_swigregister
I2c_swigregister(I2c)

class Pwm(_object):
    """


    API to Pulse Width Modulation.

    This file defines the PWM interface for libmraa

    C++ includes: pwm.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Pwm, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Pwm, name)
    __repr__ = _swig_repr

    def __init__(self, pin, owner=True, chipid=-1):
        """
        __init__(mraa::Pwm self, int pin, bool owner=True, int chipid=-1) -> Pwm

        Parameters
        ----------
        pin: int
        owner: bool
        chipid: int

        __init__(mraa::Pwm self, int pin, bool owner=True) -> Pwm

        Parameters
        ----------
        pin: int
        owner: bool

        __init__(mraa::Pwm self, int pin) -> Pwm

        Parameters
        ----------
        pin: int




        Pwm constructor, takes a pointer to the PWM context and initialises
        the class

        Parameters:
        -----------

        void:  * to a PWM context 
        """
        this = _mraa.new_Pwm(pin, owner, chipid)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mraa.delete_Pwm
    __del__ = lambda self: None

    def write(self, percentage):
        """
        write(Pwm self, float percentage) -> mraa::Result

        Parameters
        ----------
        percentage: float




        Set the output duty-cycle percentage, as a float

        Parameters:
        -----------

        percentage:  A floating-point value representing percentage of output.
        The value should lie between 0.0f (representing 0%) and 1.0f Values
        above or below this range will be set at either 0.0f or 1.0f

        Result of operation 
        """
        return _mraa.Pwm_write(self, percentage)


    def read(self):
        """
        read(Pwm self) -> float

        Parameters
        ----------
        self: mraa::Pwm *




        Read the output duty-cycle percentage, as a float

        A floating-point value representing percentage of output. The value
        should lie between 0.0f (representing 0%) and 1.0f Values above or
        below this range will be set at either 0.0f or 1.0f 
        """
        return _mraa.Pwm_read(self)


    def period(self, period):
        """
        period(Pwm self, float period) -> mraa::Result

        Parameters
        ----------
        period: float




        Set the PWM period as seconds represented in a float

        Parameters:
        -----------

        period:  Period represented as a float in seconds

        Result of operation 
        """
        return _mraa.Pwm_period(self, period)


    def period_ms(self, ms):
        """
        period_ms(Pwm self, int ms) -> mraa::Result

        Parameters
        ----------
        ms: int




        Set period, milliseconds

        Parameters:
        -----------

        ms:  milliseconds for period

        Result of operation 
        """
        return _mraa.Pwm_period_ms(self, ms)


    def period_us(self, us):
        """
        period_us(Pwm self, int us) -> mraa::Result

        Parameters
        ----------
        us: int




        Set period, microseconds

        Parameters:
        -----------

        us:  microseconds as period

        Result of operation 
        """
        return _mraa.Pwm_period_us(self, us)


    def pulsewidth(self, seconds):
        """
        pulsewidth(Pwm self, float seconds) -> mraa::Result

        Parameters
        ----------
        seconds: float




        Set pulsewidth, as represented by seconds in a float

        Parameters:
        -----------

        seconds:  The duration of a pulse

        Result of operation 
        """
        return _mraa.Pwm_pulsewidth(self, seconds)


    def pulsewidth_ms(self, ms):
        """
        pulsewidth_ms(Pwm self, int ms) -> mraa::Result

        Parameters
        ----------
        ms: int




        Set pulsewidth, milliseconds

        Parameters:
        -----------

        ms:  milliseconds for pulsewidth

        Result of operation 
        """
        return _mraa.Pwm_pulsewidth_ms(self, ms)


    def pulsewidth_us(self, us):
        """
        pulsewidth_us(Pwm self, int us) -> mraa::Result

        Parameters
        ----------
        us: int




        The pulsewidth, microseconds

        Parameters:
        -----------

        us:  microseconds for pulsewidth

        Result of operation 
        """
        return _mraa.Pwm_pulsewidth_us(self, us)


    def enable(self, enable):
        """
        enable(Pwm self, bool enable) -> mraa::Result

        Parameters
        ----------
        enable: bool




        Set the enable status of the PWM pin. None zero will assume on with
        output being driven and 0 will disable the output

        Parameters:
        -----------

        enable:  enable status of pin

        Result of operation 
        """
        return _mraa.Pwm_enable(self, enable)


    def max_period(self):
        """
        max_period(Pwm self) -> int

        Parameters
        ----------
        self: mraa::Pwm *




        Get the maximum PWM period in us

        max PWM period in us 
        """
        return _mraa.Pwm_max_period(self)


    def min_period(self):
        """
        min_period(Pwm self) -> int

        Parameters
        ----------
        self: mraa::Pwm *




        Get the minimum PWM period in us

        min PWM period in us 
        """
        return _mraa.Pwm_min_period(self)

Pwm_swigregister = _mraa.Pwm_swigregister
Pwm_swigregister(Pwm)

SPI_MODE0 = _mraa.SPI_MODE0
SPI_MODE1 = _mraa.SPI_MODE1
SPI_MODE2 = _mraa.SPI_MODE2
SPI_MODE3 = _mraa.SPI_MODE3
class Spi(_object):
    """


    API to Serial Peripheral Interface.

    This file defines the SPI interface for libmraa

    C++ includes: spi.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Spi, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Spi, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(mraa::Spi self, int bus) -> Spi

        Parameters
        ----------
        bus: int

        __init__(mraa::Spi self, int bus, int cs) -> Spi

        Parameters
        ----------
        bus: int
        cs: int




        Spi Constructor, takes a pointer to a SPI context and initialises the
        SPI class

        Parameters:
        -----------

        void:  * to SPI context 
        """
        this = _mraa.new_Spi(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mraa.delete_Spi
    __del__ = lambda self: None

    def mode(self, mode):
        """
        mode(Spi self, mraa::Spi_Mode mode) -> mraa::Result

        Parameters
        ----------
        mode: enum mraa::Spi_Mode




        Set the SPI device mode. see spidev0-3

        Parameters:
        -----------

        mode:  the mode. See Linux spidev doc

        Result of operation 
        """
        return _mraa.Spi_mode(self, mode)


    def frequency(self, hz):
        """
        frequency(Spi self, int hz) -> mraa::Result

        Parameters
        ----------
        hz: int




        Set the SPI device operating clock frequency

        Parameters:
        -----------

        hz:  the frequency to set in hz

        Result of operation 
        """
        return _mraa.Spi_frequency(self, hz)


    def writeByte(self, data):
        """
        writeByte(Spi self, uint8_t data) -> int

        Parameters
        ----------
        data: uint8_t




        Write single byte to the SPI device

        Parameters:
        -----------

        data:  the byte to send

        data received on the miso line or -1 in case of error 
        """
        return _mraa.Spi_writeByte(self, data)


    def writeWord(self, data):
        """
        writeWord(Spi self, uint16_t data) -> int

        Parameters
        ----------
        data: uint16_t




        Write buffer of bytes to SPI device The pointer return has to be
        free'd by the caller. It will return a NULL pointer in cases of error

        Parameters:
        -----------

        txBuf:  buffer to send

        length:  size of buffer (in bytes) to send

        uint8_t* data received on the miso line. Same length as passed in 
        """
        return _mraa.Spi_writeWord(self, data)


    def write(self, txBuf):
        """
        write(Spi self, uint8_t * txBuf) -> uint8_t *

        Parameters
        ----------
        txBuf: uint8_t *




        Write buffer of bytes to SPI device The pointer return has to be
        free'd by the caller. It will return a NULL pointer in cases of error

        Parameters:
        -----------

        txBuf:  buffer to send

        length:  size of buffer to send

        uint8_t* data received on the miso line. Same length as passed in 
        """
        return _mraa.Spi_write(self, txBuf)


    def lsbmode(self, lsb):
        """
        lsbmode(Spi self, bool lsb) -> mraa::Result

        Parameters
        ----------
        lsb: bool




        Change the SPI lsb mode

        Parameters:
        -----------

        lsb:  Use least significant bit transmission - 0 for msbi

        Result of operation 
        """
        return _mraa.Spi_lsbmode(self, lsb)


    def bitPerWord(self, bits):
        """
        bitPerWord(Spi self, unsigned int bits) -> mraa::Result

        Parameters
        ----------
        bits: unsigned int




        Set bits per mode on transaction, default is 8

        Parameters:
        -----------

        bits:  bits per word

        Result of operation 
        """
        return _mraa.Spi_bitPerWord(self, bits)

Spi_swigregister = _mraa.Spi_swigregister
Spi_swigregister(Spi)

class Aio(_object):
    """


    API to Analog IO.

    This file defines the aio interface for libmraa

    C++ includes: aio.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Aio, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Aio, name)
    __repr__ = _swig_repr

    def __init__(self, pin):
        """
        __init__(mraa::Aio self, int pin) -> Aio

        Parameters
        ----------
        pin: int




        Aio Constructor, takes a pointer to the AIO context and initialises
        the AIO class

        Parameters:
        -----------

        void:  * to an AIO context 
        """
        this = _mraa.new_Aio(pin)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mraa.delete_Aio
    __del__ = lambda self: None

    def read(self):
        """
        read(Aio self) -> unsigned int

        Parameters
        ----------
        self: mraa::Aio *




        Read a value from the AIO pin. By default mraa will shift the raw
        value up or down to a 10 bit value.

        Exceptions:
        -----------

        std::invalid_argument:  in case of error

        The current input voltage. By default, a 10bit value 
        """
        return _mraa.Aio_read(self)


    def readFloat(self):
        """
        readFloat(Aio self) -> float

        Parameters
        ----------
        self: mraa::Aio *




        Read a value from the AIO pin and return it as a normalized float.

        Exceptions:
        -----------

        std::invalid_argument:  in case of error

        The current input voltage as a normalized float (0.0f-1.0f) 
        """
        return _mraa.Aio_readFloat(self)


    def setBit(self, bits):
        """
        setBit(Aio self, int bits) -> mraa::Result

        Parameters
        ----------
        bits: int




        Set the bit value which mraa will shift the raw reading from the ADC
        to. I.e. 10bits

        Parameters:
        -----------

        bits:  the bits the return from read should be i.e 10

        mraa::Result type 
        """
        return _mraa.Aio_setBit(self, bits)


    def getBit(self):
        """
        getBit(Aio self) -> int

        Parameters
        ----------
        self: mraa::Aio *




        Gets the bit value mraa is shifting the analog read to.

        bit value mraa is set return from the read function 
        """
        return _mraa.Aio_getBit(self)

Aio_swigregister = _mraa.Aio_swigregister
Aio_swigregister(Aio)

class Uart(_object):
    """


    API to UART (enabling only)

    This file defines the UART interface for libmraa

    C++ includes: uart.hpp 
    """

    __swig_setmethods__ = {}
    __setattr__ = lambda self, name, value: _swig_setattr(self, Uart, name, value)
    __swig_getmethods__ = {}
    __getattr__ = lambda self, name: _swig_getattr(self, Uart, name)
    __repr__ = _swig_repr

    def __init__(self, *args):
        """
        __init__(mraa::Uart self, int uart) -> Uart

        Parameters
        ----------
        uart: int

        __init__(mraa::Uart self, std::string path) -> Uart

        Parameters
        ----------
        path: std::string




        Uart Constructor, takes a pointer to the UART context and initialises
        the UART class

        Parameters:
        -----------

        void:  * to a UART context 
        """
        this = _mraa.new_Uart(*args)
        try:
            self.this.append(this)
        except __builtin__.Exception:
            self.this = this
    __swig_destroy__ = _mraa.delete_Uart
    __del__ = lambda self: None

    def getDevicePath(self):
        """
        getDevicePath(Uart self) -> std::string

        Parameters
        ----------
        self: mraa::Uart *




        Get string with tty device path within Linux For example. Could point
        to "/dev/ttyS0"

        char pointer of device path 
        """
        return _mraa.Uart_getDevicePath(self)


    def read(self, data):
        """
        read(Uart self, char * data) -> int

        Parameters
        ----------
        data: char *




        Read bytes from the device into char* buffer

        Parameters:
        -----------

        data:  buffer pointer

        length:  maximum size of buffer

        numbers of bytes read 
        """
        return _mraa.Uart_read(self, data)


    def write(self, data):
        """
        write(Uart self, char const * data) -> int

        Parameters
        ----------
        data: char const *




        Write bytes in String object to a device

        Parameters:
        -----------

        data:  buffer pointer

        length:  maximum size of buffer

        the number of bytes written, or -1 if an error occurred 
        """
        return _mraa.Uart_write(self, data)


    def readStr(self, length):
        """
        readStr(Uart self, int length) -> std::string

        Parameters
        ----------
        length: int




        Read bytes from the device into a String object

        Parameters:
        -----------

        length:  to read

        Exceptions:
        -----------

        std::bad_alloc:  If there is no space left for read.

        string of data 
        """
        return _mraa.Uart_readStr(self, length)


    def writeStr(self, data):
        """
        writeStr(Uart self, std::string data) -> int

        Parameters
        ----------
        data: std::string




        Write bytes in String object to a device

        Parameters:
        -----------

        string:  to write

        the number of bytes written, or -1 if an error occurred 
        """
        return _mraa.Uart_writeStr(self, data)


    def dataAvailable(self, millis=0):
        """
        dataAvailable(Uart self, unsigned int millis=0) -> bool

        Parameters
        ----------
        millis: unsigned int

        dataAvailable(Uart self) -> bool

        Parameters
        ----------
        self: mraa::Uart *




        Check to see if data is available on the device for reading

        Parameters:
        -----------

        millis:  number of milliseconds to wait, or 0 to return immediately

        true if there is data available to read, false otherwise 
        """
        return _mraa.Uart_dataAvailable(self, millis)


    def flush(self):
        """
        flush(Uart self) -> mraa::Result

        Parameters
        ----------
        self: mraa::Uart *




        Flush the outbound data. Blocks until complete.

        Result of operation 
        """
        return _mraa.Uart_flush(self)


    def setBaudRate(self, baud):
        """
        setBaudRate(Uart self, unsigned int baud) -> mraa::Result

        Parameters
        ----------
        baud: unsigned int




        Set the baudrate. Takes an int and will attempt to decide what
        baudrate is to be used on the UART hardware.

        Parameters:
        -----------

        baud:  unsigned int of baudrate i.e. 9600

        Result of operation 
        """
        return _mraa.Uart_setBaudRate(self, baud)


    def setMode(self, bytesize, parity, stopbits):
        """
        setMode(Uart self, int bytesize, mraa::UartParity parity, int stopbits) -> mraa::Result

        Parameters
        ----------
        bytesize: int
        parity: enum mraa::UartParity
        stopbits: int




        Set the transfer mode For example setting the mode to 8N1 would be
        "dev.setMode(8,UART_PARITY_NONE , 1)"

        Parameters:
        -----------

        bytesize:  data bits

        parity:  Parity bit setting

        stopbits:  stop bits

        Result of operation 
        """
        return _mraa.Uart_setMode(self, bytesize, parity, stopbits)


    def setFlowcontrol(self, xonxoff, rtscts):
        """
        setFlowcontrol(Uart self, bool xonxoff, bool rtscts) -> mraa::Result

        Parameters
        ----------
        xonxoff: bool
        rtscts: bool




        Set the flowcontrol

        Parameters:
        -----------

        xonxoff:  XON/XOFF Software flow control.

        rtscts:  RTS/CTS out of band hardware flow control

        Result of operation 
        """
        return _mraa.Uart_setFlowcontrol(self, xonxoff, rtscts)


    def setTimeout(self, read, write, interchar):
        """
        setTimeout(Uart self, int read, int write, int interchar) -> mraa::Result

        Parameters
        ----------
        read: int
        write: int
        interchar: int




        Set the timeout for read and write operations <= 0 will disable that
        timeout

        Parameters:
        -----------

        read:  read timeout

        write:  write timeout

        interchar:  inbetween char timeout

        Result of operation 
        """
        return _mraa.Uart_setTimeout(self, read, write, interchar)


    def SetNonBlocking(self, nonblock):
        """
        SetNonBlocking(Uart self, bool nonblock) -> mraa::Result

        Parameters
        ----------
        nonblock: bool




        Set the blocking state for write operations

        Parameters:
        -----------

        dev:  The UART context

        nonblock:  new nonblocking state

        Result of operation 
        """
        return _mraa.Uart_SetNonBlocking(self, nonblock)

Uart_swigregister = _mraa.Uart_swigregister
Uart_swigregister(Uart)

# This file is compatible with both classic and new-style classes.


